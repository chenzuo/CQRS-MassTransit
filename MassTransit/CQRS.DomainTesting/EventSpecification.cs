using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using CQRS.Interfaces.Commands;
using CQRS.Interfaces.Events;
using NUnit.Framework;

namespace CQRS.DomainTesting
{
    public abstract class EventSpecification<TCommand> where TCommand : class, ICommand
    {
        protected IFakeEventStore EventStore;

        /// <summary>
        /// Setup - these events need to have occured to get our domain object in to a valid initial state
        /// </summary>
        /// <returns></returns>
        public abstract IEnumerable<IEvent> Given(); 

        /// <summary>
        /// The command to apply to the domain object
        /// </summary>
        /// <returns></returns>
        public abstract TCommand When();
        
        /// <summary>
        /// The command handler that will initialize the domin object and invoke the command on the domain object
        /// </summary>
        /// <returns></returns>
        public abstract Interfaces.Commands.Handles<TCommand> BuildCommandHandler();

        /// <summary>
        /// The events that we expect to the generated when the command is applied to the domain object
        /// </summary>
        /// <returns></returns>
        public abstract IEnumerable<IEvent> Then(); //the events that we expect to be generated by the SUT
        
        public abstract Expression<Predicate<Exception>> ThenException();

        public static IEnumerable<IEvent> NoEvents 
        {
            get { return new IEvent[0]; }
        }

        public static Expression<Predicate<Exception>> NoException
        {
            get { return exception => exception == null; }
        }

        /// <summary>
        /// Tear down and cleanup when the test has finished
        /// </summary>
        public abstract void Finally();

        [Test]
        public void RunTest()
        {
            EventStore = new FakeEventStore(Given());
            var commandHandler = BuildCommandHandler();
            List<IEvent> expected = Then().ToList();
            List<IEvent> produced = new List<IEvent>();

            try
            {
                commandHandler.Handle(When());
                produced = EventStore.PeakChanges().ToList();
            }
            catch (Exception exception)
            {
                if (ThenException().Compile()(exception))
                {
                    Assert.Pass();
                }

                Type exceptionType = ThenException().Parameters[0].Type;
                Assert.Fail(string.Format("Received an exception ({0}) that failed the provided predicate.",
                                          exceptionType));
            }
            finally
            {
                Finally();
            }

            string comparisonResults = EventComparer.Instance.Compare(expected, produced, new[] {"CorrelationId"});

            if(comparisonResults == null)
                Assert.Pass();

            Assert.Fail(string.Format("Actual events do not match the expected events: {0}{1}", Environment.NewLine,
                                      comparisonResults));
        }
    }
}
